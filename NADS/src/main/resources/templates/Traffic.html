<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Traffic Graph</title>
</head>
<body>
	<h1 align="center">트래픽 그래프</h1>

	<!-- jQuery CDN 설치 -->
	<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

	<!-- Chart.js 설치 -->
	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

	<!-- 날짜 및 시간대 설정 -->
	<div align="center" id="choiceDetail">
		<form action="/api/elastic/all" id="choiceDateForm">
			<input type="datetime-local" id="choiceDate" name="choiceDate">
			<input type="datetime-local" id="choiceDateEnd" name="choiceDateEnd">
			<button type="submit">조회</button>
		</form>
	</div>
	<div align="right" id="playOrstop">
		<button id="tempStop">일시정지</button>
		<button id="play">재생</button>
	</div>

	<!-- main 그래프 -->
	<div align="center">
		<div id="selectedDate" align="left"></div>
		<!-- 날짜 표시 영역 -->
		<canvas id="lineChart" height="100"></canvas>
	</div>

	<script>
		$(document).ready(function(){
			// 전역 변수
			let lineChart;
			let updateInterval;	// 업데이트 간격
			let date = [];		// x축에 들어갈 날짜
			let tfData = [];	// Traffic
			let maxYValue = 0;	// y축 최대값
			
			// 페이지 로드 시 기본 쿼리 실행 (choiceDate, choiceDateEnd 없이)
			fetchElasticData(null, null);
			
			// 기존 폼 제출 동작을 막고 AJAX 요청을 보냄
			$('#choiceDateForm').submit(function(event){
				event.preventDefault(); // 기본 폼 제출 방지
				const choiceDate = $('#choiceDate').val(); // 선택한 날짜와 시간 값 가져오기
				const choiceDateEnd = $('#choiceDateEnd').val(); // 선택한 날짜와 시간 값 가져오기
				
				// 이전 업데이트 주기 제거
	            if (updateInterval) {
	                clearInterval(updateInterval);
	                updateInterval = null;
	            }
				
				// 선택한 choiceDate로 데이터 가져오기
				fetchElasticData(choiceDate, choiceDateEnd);
				
			});
			
			// ==================== Traffic 데이터 불러오기
			function fetchElasticData(choiceDate, choiceDateEnd){
				let requestData = {};
				if (choiceDate) requestData.choiceDate = choiceDate;
			    if (choiceDateEnd) requestData.choiceDateEnd = choiceDateEnd;
				
				$.ajax({
					url: "/api/elastic/all",
					type: "GET",
					data: requestData,
					success: function(trafficData){
						// 시간 필드를 기준으로 오름차순 정렬
						trafficData.sort(function(a, b){
							return new Date(a.time) - new Date(b.time);
						});
						
						// 데이터 범위 설정 : 첫 번째와 마지막 시간 가져오기
						const startDate = new Date(trafficData[0].time);
						const endDate = new Date(trafficData[trafficData.length - 1].time);
						
						// date와 tfData 배열 초기화
						date = [];		
						tfData = [];		
						
						// StartDate에서 endDate까지 1초 간격으로 시간 설정 
						let currentDate = new Date(startDate);
						
						// while문 시작 ============
						while (currentDate <= endDate){
						
							// 현재 시간을 "HH:MM:SS" 형식으로 저장
							const formattedDate = `${currentDate.getHours()}:${currentDate.getMinutes()}:${currentDate.getSeconds()}`;
							date.push(formattedDate);
							
							// 현재 초에 해당하는 모든 txRate 값 합산
							const sumTxRate = trafficData
								.filter(item => {
									const itemDate = new Date(item.time);
									return(
										itemDate.getHours() === currentDate.getHours() &&
			                            itemDate.getMinutes() === currentDate.getMinutes() &&
			                            itemDate.getSeconds() === currentDate.getSeconds()
			                        );
								})
								.reduce((sum, item) => sum + (item.txRate || 0), 0);
							
							// 합산한 txRate를 tfData에 추가
							tfData.push(sumTxRate);
							
							// 1초씩 추가
							currentDate.setSeconds(currentDate.getSeconds()+1);
						}
						// ========== while문 끝
						
						$('#selectedDate').text(`2024년 ${currentDate.getMonth()+1}월 ${currentDate.getDate()}일`)
						 
 						/* trafficData.forEach(function(item){
							if(item.txRate != null){
								const originalDate = new Date(item.time);	//  originalDate를 Date 객체로 변환
								const formattedDate = `${originalDate.getHours()}:${originalDate.getMinutes()}:${originalDate.getSeconds()}`;
								date.push(formattedDate); 
								tfData.push(item.txRate);
								$('#selectedDate').text(`2024년 ${originalDate.getMonth()+1}월 ${originalDate.getDate()}일`)
							}
						}); */
						
 						// y축 설정을 위한 tfData 최대값 구하기
 						const maxTfData = Math.ceil(Math.max(...tfData) / 1000) * 1000;
 						maxYValue = maxTfData + 1000;
 						
 						createChart();
					},	
					error: function(){
						console.log("데이터 불러오기 실패")
					}
				});
			}
			
			function createChart(){
				if(lineChart){
						lineChart.destroy();
					}
					
					// 차트에서 한 번에 보여줄 데이터 수 설정
					const visibleCount = 50;
					let startIndex = 0;
					
					// 라인 차트 생성
					const ctx = document.getElementById('lineChart').getContext('2d');
					
					// new Chart(ctx, {}) 와 const config = {} 의 차이
					// 1. new Chart..는 한 번에 차트에 대한 모든 정보를 담을 때
					// 2. const config..는 차트의 설정을 미리 config(객체)로 정의한 후 이 객체를 사용하여 차트 생성
					lineChart = new Chart(ctx, {
					type: 'line',
					data: {
						labels: date.slice(startIndex, startIndex + visibleCount),
						datasets: [
							{
								label: 'Traffic',
								data: tfData.slice(startIndex, startIndex + visibleCount),
								tension: 0.5,
								borderColor: 'rgb(68, 113, 218)',
								borderWidth: 2,
								pointRadius: 0,
								/* fill: {			// 임계값 설정 후 적용할 내용
									target: 1,
									above: 'rgba(204, 61, 61, 0.4)',
									below: 'rgba(255, 255, 255, 0)'
								} */
							}
						]
					},
					options: {
						responsive: true,
						scales: {
							x: {
								grid: {
									display: false
								}
							},
							y: {
								beginAtZero: true,	// 축이 0부터 시작할지 여부
								max: maxYValue
							}
						},
						plugins: {
							tooltip: {	// chart 위에 마우스를 올리면 데이터 포인트와 관련된 정보 표시
								intersect: false,	// 마우스가 정확히 데이터 포인트 위에 있을 때만 표시될지 여부
													// 기본값 : true, false면 포인트 가까이만 있어도 tooltip 표시
								displayColors: false,	// label의 색상 상자 표시 여부
								titleFont: {
									size: 20,
									family: 'Rethink Sans',
									weight: 'bold'
								},
								bodyFont: {
									size: 15,
									family: 'Rethink Sans'
								},
								cornerRadius: 10,	// tooltip 둥근 모서리(기본값 : 6)
								caretSize: 8,		// tooltip이 차트 요소를 가리키는 작은 삼각형
								callbacks: {
									title: function(tooltipItems){
										return 'Details';
									},
									label: function(tooltipItems){
										return '• Traffic  :  '+tooltipItems.raw;
									},
									afterLabel: function(tooltipItems){
										const afterLabelInfo = [];
										afterLabelInfo.push('• Date  :  '+tooltipItems.label);
										
										const dataIndex = tooltipItems.dataIndex + startIndex;
										
										console.log("dataIndex: ", dataIndex)
										
										return afterLabelInfo;
									}
								}
							}
						},
						hover : {
							mode: 'index',		// 마우스를 올렸을 때 반응하는 차트 요소의 범위
							intersect: false	// 마우스가 요소와 교차할 때만 호버 효과가 발생할지 여부 설정
						},
						animation: {
							duration: 0
						}
					}
					});
				
					
					function updateChart(){
						startIndex += 1;
						
						// 데이터의 끝에 도달하면 처음으로 돌아가도록 설정
					    if (startIndex + visibleCount > date.length) {
					        startIndex = 0;
					    }
						
						// 새로운 범위의 데이터로 차트 업데이트
						lineChart.data.labels = date.slice(startIndex, startIndex+visibleCount);
						lineChart.data.datasets[0].data = tfData.slice(startIndex, startIndex+visibleCount);
						
						// 새로운 범위로 차트 갱신
						lineChart.update();
					}
					
					// 업데이트 주기 설정
					updateInterval = setInterval(updateChart, 1000);
					
					// 일시정지 버튼 클릭 시 차트 업데이트
					document.getElementById('tempStop').addEventListener('click', function(){
						clearInterval(updateInterval);
						updateInterval = null;
					});
					
					// 재생 버튼 클릭 시 차트 업데이트
					document.getElementById('play').addEventListener('click', function() {
			            // 기존 인터벌이 이미 멈춰있다면 재시작
			            if (!updateInterval) {
			                updateInterval = setInterval(updateChart, 1000);
			            }
			        });
			}
		});
	</script>

	<form action="/main" method="post" align="center">
		<button type="submit">메인으로 돌아가기</button>
	</form>

</body>
</html>