<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Traffic Graph</title>
</head>
<body>
	<h1 align="center">트래픽 그래프</h1>

	<!-- jQuery CDN 설치 -->
	<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

	<!-- Chart.js 설치 -->
	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

	<!-- 날짜 및 시간대 설정 -->
	<div align="center" id="choiceDetail">
		<form action="/api/elastic/all" id="choiceDateForm">
			<input type="datetime-local" id="choiceDate" name="choiceDate">
			<input type="datetime-local" id="choiceDateEnd" name="choiceDateEnd">
			<button type="submit">조회</button>
		</form>
	</div>
	<div align="right" id="playOrstop">
		<button id="tempStop">일시정지</button>
		<button id="play">재생</button>
	</div>

	<!-- main 그래프 -->
	<div align="center">
		<div id="selectedDate" align="left"></div>
		<!-- 날짜 표시 영역 -->
		<canvas id="lineChart" height="100"></canvas>
	</div>

	<script>
		$(document).ready(function(){
			// 전역 변수
			let lineChart;
			let date = [];		// x축에 들어갈 날짜
			let tfData = [];	// Traffic
			let thData = [];	// Threshold
			let maxYValue = 0;	// y축 최대값
			const visibleCount = 50;	// 그래프에서 한 번에 보여줄 데이터 개수
			let startIndex = 0;			// 그래프 시작 인덱스 0
			let isPaused = false;
			let count = 0;
			
			// 웹 소켓 연결 설정 : WebSocket 서버의 URL 설정
			const socket = new WebSocket("ws://localhost:8081/data");
			
			socket.onopen = function(){
				console.log("WebSocket 연결이 열렸습니다.");
			};
			
			socket.onmessage = function(event){
				const messageData = JSON.parse(event.data);
			
				// 받은 데이터 처리
				if(!isPaused && messageData && messageData.time && messageData.txRate && messageData.traffic){
					
					date.push(messageData.time);
					console.log("date : ", date);
					
					tfData.push(messageData.txRate); // Traffic
					console.log("tfData : ", tfData);
					
					thData.push(messageData.traffic); // Threshold
					console.log("thData : ", thData);
						
					// visibleCount 초과 시 이전 데이터는 제거
					if(date.length > visibleCount){
						date.shift();
						tfData.shift();
						thData.shift();
					}
				}
					
				updateMaxYValue();
				
				// 차트 업데이트
				updateChart();
			};
			
			socket.onclose = function(){
				console.log("WebSocket 연결이 닫혔습니다.");
			} 
			
			
			// y축 최대값 업데이트 할 수 있는 함수
			function updateMaxYValue() {
			    const maxTfData = Math.max(...tfData); // tfData에서 현재 최대값 찾기
			    const maxThData = Math.max(...thData); // thData에서 현재 최대값 찾기
			    maxYValue = Math.ceil((Math.max(maxTfData, maxThData) + 1000) / 1000) * 1000; // 1000 단위로 올림하여 설정
			}
			
			
			function updateChart(){
				if(lineChart){
					lineChart.destroy();
				}
				
				const ctx = document.getElementById('lineChart').getContext('2d');
				
				// 트래픽이 임계값을 넘을 때마다 count 증가
			    for (let i = 0; i < tfData.length; i++) {
			        if (tfData[i] > thData[i]) {
			            count += 1;  // 임계값 초과 시 count 증가
			            console.log("count : ", count);
			        }
			    }
				
				lineChart = new Chart(ctx, {
					type: 'line',
					data: {
						labels: date.slice(startIndex, startIndex + visibleCount),
						datasets: [
							{
								label: 'Traffic',
								data: tfData.slice(startIndex, startIndex + visibleCount),
								tension: 0.5,
								borderColor: 'rgb(68, 113, 218)',
								borderWidth: 2,
								pointRadius: 0,
								fill: {			// 임계값 설정 후 적용할 내용
									target: 1,
									above: 'rgba(204, 61, 61, 0.4)',
									below: 'rgba(255, 255, 255, 0)'
								}
							},
							{
								label: 'Threshold',
								data: thData.slice(startIndex, startIndex + visibleCount),
								tension: 0.5,
								borderColor: 'rgb(255, 51, 51)',
								borderWidth: 2,
								pointRadius: 0,
							} 
						]
					},
					options: {
						responsive: true,
						scales: {
							x: {
								grid: {
									display: false
								}
							},
							y: {
								beginAtZero: true,	// 축이 0부터 시작할지 여부
								max: maxYValue
							}
						},
						plugins: {
							tooltip: {	// chart 위에 마우스를 올리면 데이터 포인트와 관련된 정보 표시
								intersect: false,	// 마우스가 정확히 데이터 포인트 위에 있을 때만 표시될지 여부
													// 기본값 : true, false면 포인트 가까이만 있어도 tooltip 표시
								displayColors: false,	// label의 색상 상자 표시 여부
								titleFont: {
									size: 20,
									family: 'Rethink Sans',
									weight: 'bold'
								},
								bodyFont: {
									size: 15,
									family: 'Rethink Sans'
								},
								cornerRadius: 10,	// tooltip 둥근 모서리(기본값 : 6)
								caretSize: 8,		// tooltip이 차트 요소를 가리키는 작은 삼각형
								callbacks: {
									title: function(tooltipItems){
										return 'Details';
									},
									label: function(tooltipItems){
										if(tooltipItems.datasetIndex === 0){
											return '• Traffic  :  '+tooltipItems.raw;
										}else if(tooltipItems.datasetIndex === 1){
											return '• Threshold  :  '+tooltipItems.raw;
										}
									},
									afterLabel: function(tooltipItems){
										const afterLabelInfo = [];
										const dataIndex = tooltipItems.dataIndex + startIndex;
									    
										if(dataIndex < date.length){
											const formattedDate = date[dataIndex]; // "HH:MM:SS" 형식
											// "HH:MM:SS" 형식을 "HH시 MM분 SS초"로 변환
										    const [hours, minutes, seconds] = formattedDate.split(':');
										    const koreanFormattedDate = `${hours}시 ${minutes}분 ${seconds}초`;
										    afterLabelInfo.push('• Date  :  ' + koreanFormattedDate);
										}
										
										return afterLabelInfo;
									}
								}
							}
						},
						hover : {
							mode: 'index',		// 마우스를 올렸을 때 반응하는 차트 요소의 범위
							intersect: false	// 마우스가 요소와 교차할 때만 호버 효과가 발생할지 여부 설정
						},
						animation: {
							duration: 0
						}
					}
				});
			}
			
			//일시정지 버튼 클릭 시 차트 업데이트
			document.getElementById('tempStop').addEventListener('click', function(){
				isPaused = true;
				updateInterval = null;
			});
			
			// 재생 버튼 클릭 시 차트 업데이트
			document.getElementById('play').addEventListener('click', function() {
	            // 기존 인터벌이 이미 멈춰있다면 재시작
	            if(isPaused){
					isPaused = false;
					console.log("그래프가 재생됩니다.");
	            }
	        });
			
		});
		
	</script>

	<form action="/main" method="post" align="center">
		<button type="submit">메인으로 돌아가기</button>
	</form>

</body>
</html>