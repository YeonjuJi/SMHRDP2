<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<!--<meta name=description content="This site was generated with Anima. www.animaapp.com"/>-->
<!-- <link rel="shortcut icon" type=image/png href="https://animaproject.s3.amazonaws.com/home/favicon.png" /> -->
<meta name="viewport" content="width=1440, maximum-scale=1.0" />
<link rel="shortcut icon" type="image/png"
	href="https://animaproject.s3.amazonaws.com/home/favicon.png" />
<meta name="og:type" content="website" />
<meta name="twitter:card" content="photo" />
<link rel="stylesheet" type="text/css" href="css/desktop-1.css" />
<link rel="stylesheet" type="text/css" href="css/styleguide.css" />
<link rel="stylesheet" type="text/css" href="css/globals.css" />
<link rel="stylesheet" type="text/css" href="css/Home.css" />
<style>
.notification-container {
	position: fixed;
	top: 10%;
	right: 2%;
	width: 300px;
	z-index: 1000;
	background: #fff;
	box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
	border-radius: 5px;
	padding: 15px;
	display: none;
}

.notification-header {
	display: flex;
	justify-content: space-between;
	align-items: center;
}

.notification-title {
	font-weight: bold;
	font-size: 16px;
	color: #e74c3c;
}

.notification-close {
	cursor: pointer;
	background: none;
	border: none;
	font-size: 18px;
}

.notification-body {
	margin-top: 10px;
	font-size: 14px;
	color: #333;
}
</style>
</head>
<body style="margin: 0; background: #f5f6fa">
	<input type="hidden" id="anPageName" name="page" value="desktop-1" />
	<div class="container-center-horizontal">
		<div class="desktop-1 screen">
			<div class="overlap-group16">
				<div class="overlap-group15">
					<div class="overlap-group10">


						<div class="navigation-sidebar-1">
							<div class="overlap-group-1">


								<!-- 사이드바 시작 -->


								<a href="/main">
									<div class="navigation-sidebar-item-light2">
										<div
											class="products-1 products-8 nunitosans-semi-bold-shark-14px">Home</div>
									</div>
								</a> <a href="/traffic">
									<div class="navigation-sidebar-item-light3">
										<div
											class="products-2 products-8 nunitosans-semi-bold-shark-14px">Traffic</div>
									</div>
								</a> <a href="/monthGph">
									<div class="navigation-sidebar-item-light4">
										<div
											class="products-3 products-8 nunitosans-semi-bold-shark-14px">Session</div>
									</div>
								</a> <a href="/weekGph">
									<div class="navigation-sidebar-item-light5">
										<div
											class="products-4 products-8 nunitosans-semi-bold-shark-14px">Cpu</div>
									</div>
								</a> <a href="/countryGph">
									<div class="navigation-sidebar-item-light6">
										<div
											class="products-5 products-8 nunitosans-semi-bold-shark-14px">Memories</div>
									</div>
								</a> <img class="divider" src="img/divider.svg" alt="Divider" />
								<div class="pages">PAGES</div>



								<!-- 클래스 수정 -->
								<a href="/setting">
									<div
										class="navigation-sidebar-item-light-1 navigation-sidebar-item-light-3">

										<div
											class="products-6 products-8 nunitosans-semi-bold-shark-14px">Setting</div>
									</div>
								</a>
								<!-- 클래스 수정 -->

							</div>

							<!-- 사이드바 끝 -->

							<img class="divider-1 divider-7" src="img/divider.svg"
								alt="Divider" /> <img class="divider-2 divider-7"
								src="img/divider.svg" alt="Divider" /> <img
								class="group-1000000873" src="img/group-1000000873@2x.png"
								alt="Group 1000000873" />
						</div>
						<div class="navigation-top-bar-light">
							<div class="overlap-group2">
								<div class="icon">

									<img class="path-1" src="img/base-1@2x.png" alt="Path" />
								</div>

								<div class="overlap-group3">
									<div class="overlap-group-3">

										<div class="icon-1" onclick="toggleNotification()">

											<img class="combined-shape" src="img/combined-shape.svg"
												alt="Combined Shape" />
											<div class="rectangle-23"></div>
										</div>
										<img class="oval" src="img/oval-1.svg" alt="Oval" />
										<div class="number">6</div>
									</div>
									<img class="oval-1" src="img/oval.svg" alt="Oval" />
								</div>

								
								<div class="profile">
									<img class="man-438081_960_720"
										src="img/man-438081-960-720@2x.png" alt="man-438081_960_720" />
									<div class="flex-col">
										<div class="jone-aly">Moni Roy</div>
										<div class="admin">Admin</div>
									</div>
									<img class="more" src="img/more@2x.png" alt="More" />
								</div>
							</div>
						</div>
					</div>
					<div class="flex-col-1 flex-col-3">
						<div class="overlap-group-container">
							<div class="overlap-group1">
								<iframe
									src="http://223.130.139.47:5601/app/dashboards#/view/b73f71b0-9be1-11ef-aa42-b793711d88be?embed=true&_g=(filters%3A!()%2CrefreshInterval%3A(pause%3A!t%2Cvalue%3A0)%2Ctime%3A(from%3Anow-1d%2Fd%2Cto%3Anow))&hide-filter-bar=true"
									height="230" width="100%"></iframe>
							</div>
						</div>
						<div class="product-card">
							<div class="overlap-group5">
								<div class="box-4 box-5"></div>

								<!-- 수정한 부분 임 -->
								<div class="overlap-group5">
									<div class="box-4 box-5">
										<!-- 연주가 추가한 트래픽 그래프 -->
										<!-- 날짜 및 시간대 설정 -->
										<div align="center" id="choiceDetail">
											<form action="/api/elastic/all" id="choiceDateForm">
												<label for="choiceDate">시작</label> <input
													type="datetime-local" id="choiceDate" name="choiceDate">
												<label for="choiceDateEnd">종료 </label> <input
													type="datetime-local" id="choiceDateEnd"
													name="choiceDateEnd">
												<button type="submit">조회</button>
											</form>
										</div>

										<!-- 일시정지, 재생 버튼 -->
										<div align="right" id="playOrstop">

											<div>
												<!-- 그래프 날짜 -->
												<div id="selectedDate" align="left"></div>
												<canvas id="lineChart" height="400" width="1098"></canvas>
											</div>

											<button id="tempStop">일시정지</button>
											<button id="play">재생</button>
										</div>

										<!-- ============추후에 세션 그래프로 바꿀 예정================== -->
										<!-- 연주가 추가한 트래픽 그래프 -->

										<!-- 일시정지, 재생 버튼 -->
										<div align="right" id="playOrstop">

											<div>
												<!-- 그래프 날짜 -->
												<div id="selectedDate" align="left"></div>
												<canvas id="lineChartSession" height="400" width="1098"></canvas>
											</div>

											<button id="tempStop">일시정지</button>
											<button id="play">재생</button>
										</div>


										<!-- 기존 키바나 그래프 -->
										<div class="iframe-container">
											<iframe
												src="http://223.130.139.47:5601/app/dashboards#/view/c1ea3c70-9a66-11ef-aa42-b793711d88be?embed=true&_g=(filters%3A!()%2Cquery%3A(language%3Akuery%2Cquery%3A'')%2CrefreshInterval%3A(pause%3A!t%2Cvalue%3A0)%2Ctime%3A(from%3Anow-15m%2Cto%3Anow))&hide-filter-bar=true"
												height="460" width="1138"></iframe>

										</div>
										<!-- Insert the canvas for the bar chart above the image -->
									</div>
								</div>
							</div>
						</div>
					</div>
				</div>
			</div>
		</div>

		<!-- 알림 컨테이너 -->
		<div id="notification" class="notification-container">
			<div class="notification-header">
				<span class="notification-title">Warning: High Traffic
					Detected</span>
				<button class="notification-close" onclick="closeNotification()">&times;</button>
			</div>
			<div class="notification-body">
				- Traffic increased significantly.<br> - Immediate action
				required.
			</div>
		</div>

		<!-- Chart.js -->
		<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

		<!-- jQuery CDN 설치 -->
		<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

		<script
			src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@latest"></script>


		<!-- ================================================================================ -->
<script>
		$(document).ready(function(){
			// 전역 변수
			let lineChart;
			let updateInterval;	// 업데이트 간격
			let date = [];		// x축에 들어갈 날짜
			let tfData = [];	// Traffic
			let maxYValue = 0;	// y축 최대값
			
			// 페이지 로드 시 기본 쿼리 실행 (choiceDate, choiceDateEnd 없이)
			fetchElasticData(null, null);
			
			// 기존 폼 제출 동작을 막고 AJAX 요청을 보냄
			$('#choiceDateForm').submit(function(event){
				event.preventDefault(); // 기본 폼 제출 방지
				const choiceDate = $('#choiceDate').val(); // 선택한 날짜와 시간 값 가져오기
				const choiceDateEnd = $('#choiceDateEnd').val(); // 선택한 날짜와 시간 값 가져오기
				
				// 이전 업데이트 주기 제거
	            if (updateInterval) {
	                clearInterval(updateInterval);
	                updateInterval = null;
	            }
				
				// 선택한 choiceDate로 데이터 가져오기
				fetchElasticData(choiceDate, choiceDateEnd);
				
			});
			
			// ==================== Traffic 데이터 불러오기
			function fetchElasticData(choiceDate, choiceDateEnd){
				let requestData = {};
				if (choiceDate) requestData.choiceDate = choiceDate;
			    if (choiceDateEnd) requestData.choiceDateEnd = choiceDateEnd;
				
				$.ajax({
					url: "/api/elastic/all",
					type: "GET",
					data: requestData,
					success: function(trafficData){
						// 시간 필드를 기준으로 오름차순 정렬
						trafficData.sort(function(a, b){
							return new Date(a.time) - new Date(b.time);
						});
						
						// 데이터 범위 설정 : 첫 번째와 마지막 시간 가져오기
						const startDate = new Date(trafficData[0].time);
						const endDate = new Date(trafficData[trafficData.length - 1].time);
						
						// date와 tfData 배열 초기화
						date = [];		
						tfData = [];		
						
						// StartDate에서 endDate까지 1초 간격으로 시간 설정 
						let currentDate = new Date(startDate);
						
						// while문 시작 ============
						while (currentDate <= endDate){
						
							// 현재 시간을 "HH:MM:SS" 형식으로 저장
							const formattedDate = `${currentDate.getHours()}:${currentDate.getMinutes()}:${currentDate.getSeconds()}`;
							date.push(formattedDate);
							
							// 현재 초에 해당하는 모든 txRate 값 합산
							const sumTxRate = trafficData
								.filter(item => {
									const itemDate = new Date(item.time);
									return(
										itemDate.getHours() === currentDate.getHours() &&
			                            itemDate.getMinutes() === currentDate.getMinutes() &&
			                            itemDate.getSeconds() === currentDate.getSeconds()
			                        );
								})
								.reduce((sum, item) => sum + (item.txRate || 0), 0);
							
							// 합산한 txRate를 tfData에 추가
							tfData.push(sumTxRate);
							
							// 1초씩 추가
							currentDate.setSeconds(currentDate.getSeconds()+1);
						}
						// ========== while문 끝
						
						$('#selectedDate').text(`2024년 ${currentDate.getMonth()+1}월 ${currentDate.getDate()}일`)
						 
 						/* trafficData.forEach(function(item){
							if(item.txRate != null){
								const originalDate = new Date(item.time);	//  originalDate를 Date 객체로 변환
								const formattedDate = `${originalDate.getHours()}:${originalDate.getMinutes()}:${originalDate.getSeconds()}`;
								date.push(formattedDate); 
								tfData.push(item.txRate);
								$('#selectedDate').text(`2024년 ${originalDate.getMonth()+1}월 ${originalDate.getDate()}일`)
							}
						}); */
						
 						// y축 설정을 위한 tfData 최대값 구하기
 						const maxTfData = Math.ceil(Math.max(...tfData) / 1000) * 1000;
 						maxYValue = maxTfData + 1000;
 						
 						if(lineChart){
 							lineChart.destroy();
 						}
 						
 						// 차트에서 한 번에 보여줄 데이터 수 설정
 						const visibleCount = 50;
 						let startIndex = 0;
 						
 						// 라인 차트 생성
 						const ctx = document.getElementById('lineChart').getContext('2d');
 						
 						// new Chart(ctx, {}) 와 const config = {} 의 차이
 						// 1. new Chart..는 한 번에 차트에 대한 모든 정보를 담을 때
 						// 2. const config..는 차트의 설정을 미리 config(객체)로 정의한 후 이 객체를 사용하여 차트 생성
 						lineChart = new Chart(ctx, {
 						type: 'line',
 						data: {
 							labels: date.slice(startIndex, startIndex + visibleCount),
 							datasets: [
 								{
 									label: 'Traffic',
 									data: tfData.slice(startIndex, startIndex + visibleCount),
 									tension: 0.5,
 									borderColor: 'rgb(68, 113, 218)',
 									borderWidth: 2,
 									pointRadius: 0,
 									/* fill: {			// 임계값 설정 후 적용할 내용
 										target: 1,
 										above: 'rgba(204, 61, 61, 0.4)',
 										below: 'rgba(255, 255, 255, 0)'
 									} */
 								}
 							]
 						},
 						options: {
 							responsive: true,
 							scales: {
 								x: {
 									grid: {
 										display: false
 									}
 								},
 								y: {
 									beginAtZero: true,	// 축이 0부터 시작할지 여부
 									max: maxYValue
 								}
 							},
 							plugins: {
 								tooltip: {	// chart 위에 마우스를 올리면 데이터 포인트와 관련된 정보 표시
 									intersect: false,	// 마우스가 정확히 데이터 포인트 위에 있을 때만 표시될지 여부
 														// 기본값 : true, false면 포인트 가까이만 있어도 tooltip 표시
 									displayColors: false,	// label의 색상 상자 표시 여부
 									titleFont: {
 										size: 20,
 										family: 'Rethink Sans',
 										weight: 'bold'
 									},
 									bodyFont: {
 										size: 15,
 										family: 'Rethink Sans'
 									},
 									cornerRadius: 10,	// tooltip 둥근 모서리(기본값 : 6)
 									caretSize: 8,		// tooltip이 차트 요소를 가리키는 작은 삼각형
 									callbacks: {
 										title: function(tooltipItems){
 											return 'Details';
 										},
 										label: function(tooltipItems){
 											return '• Traffic  :  '+tooltipItems.raw;
 										},
 										afterLabel: function(tooltipItems){
 											const afterLabelInfo = [];
 											afterLabelInfo.push('• Date  :  '+tooltipItems.label);
 											
 											const dataIndex = tooltipItems.dataIndex + startIndex;
 											
 											console.log("dataIndex: ", dataIndex)
 											
 											return afterLabelInfo;
 										}
 									}
 								}
 							},
 							hover : {
 								mode: 'index',		// 마우스를 올렸을 때 반응하는 차트 요소의 범위
 								intersect: false	// 마우스가 요소와 교차할 때만 호버 효과가 발생할지 여부 설정
 							},
 							animation: {
 								duration: 0
 							}
 						}
 						});
 					
 						
 						function updateChart(){
 							startIndex += 1;
 							
 							// 데이터의 끝에 도달하면 처음으로 돌아가도록 설정
 						    if (startIndex + visibleCount > date.length) {
 						        startIndex = 0;
 						    }
 							
 							// 새로운 범위의 데이터로 차트 업데이트
 							lineChart.data.labels = date.slice(startIndex, startIndex+visibleCount);
 							lineChart.data.datasets[0].data = tfData.slice(startIndex, startIndex+visibleCount);
 							
 							// 새로운 범위로 차트 갱신
 							lineChart.update();
 						}
 						
 						// 업데이트 주기 설정
 						updateInterval = setInterval(updateChart, 1000);
 						
 						// 일시정지 버튼 클릭 시 차트 업데이트
 						document.getElementById('tempStop').addEventListener('click', function(){
 							clearInterval(updateInterval);
 							updateInterval = null;
 						});
 						
 						// 재생 버튼 클릭 시 차트 업데이트
 						document.getElementById('play').addEventListener('click', function() {
 				            // 기존 인터벌이 이미 멈춰있다면 재시작
 				            if (!updateInterval) {
 				                updateInterval = setInterval(updateChart, 1000);
 				            }
 				        });
					},	
					error: function(){
						console.log("데이터 불러오기 실패")
					}
				});
			}
		});
	</script>

		<!-- ================================================================================ -->


		<!-- ============================여기는 언젠가 session 그래프 영역========================= -->
		<script>
   // Entity 데이터 불러오기
   $(document).ready(function(){
      // 전역 변수
      let lineChart;
      let updateInterval;
      let date = [];
      let tfData = [];
      
      // 페이지 로드 시 기본 쿼리 실행 (choiceDate, choiceDateEnd 없이)
      fetchData(null, null);
      
      // 기존 폼 제출 동작을 막고 AJAX 요청을 보냄
      $('#choiceDateForm').submit(function(event){
         event.preventDefault(); // 기본 폼 제출 방지
         const choiceDate = $('#choiceDate').val(); // 선택한 날짜와 시간 값 가져오기
         const choiceDateEnd = $('#choiceDateEnd').val(); // 선택한 날짜와 시간 값 가져오기
         
         // 이전 업데이트 주기 제거
            if (updateInterval) {
                clearInterval(updateInterval);
                updateInterval = null;
            }
         
         // 선택한 choiceDate로 데이터 가져오기
         fetchData(choiceDate, choiceDateEnd);
         
      });
         
      function fetchData(choiceDate, choiceDateEnd){
         let requestData = {};
         if (choiceDate) requestData.choiceDate = choiceDate;
          if (choiceDateEnd) requestData.choiceDateEnd = choiceDateEnd;
         
         $.ajax({
            url: "/api/elastic/all",
            type: "GET",
            data: requestData,
            success: function(trafficData){
               // 시간 필드를 기준으로 오름차순 정렬
               trafficData.sort(function(a, b){
                  return new Date(a.time) - new Date(b.time);
               });
               
               // 데이터 범위 설정 : 첫 번째와 마지막 시간 가져오기
               const startDate = new Date(trafficData[0].time);
               const endDate = new Date(trafficData[trafficData.length - 1].time);
               console.log("startDate : ", startDate);
               console.log("endDate : ", endDate);
               
               
               // 가져온 elastic 데이터를 배열에 집어 넣기
                date = [];      // 형식을 바꾼 날짜
                tfData = [];      // 트래픽
               
                  console.log('tfData : ', tfData);
               
                trafficData.forEach(function(item){
                  if(item.txRate != null){
                     const originalDate = new Date(item.time);   //  originalDate를 Date 객체로 변환
                     const formattedDate = `${originalDate.getHours()}:${originalDate.getMinutes()}:${originalDate.getSeconds()}`;
                     date.push(formattedDate); 
                     tfData.push(item.txRate);
                     $('#selectedDate').text(`2024년 ${originalDate.getMonth()+1}월 ${originalDate.getDate()}일`)
                  }
               });
                // y축 설정을 위한 tfData 최대값 구하기
                const maxTfData = Math.ceil(Math.max(...tfData) / 1000) * 1000;
                const maxYValue = maxTfData + 1000;
                
                if(lineChart){
                   lineChart.destroy();
                }
                
             
             // 차트에서 한 번에 보여줄 데이터 수 설정
             const visibleCount = 50;
             let startIndex = 0;
             
             // 라인 차트 생성
             const ctx = document.getElementById('lineChartSession').getContext('2d');
             
             // new Chart(ctx, {}) 와 const config = {} 의 차이
             // 1. new Chart..는 한 번에 차트에 대한 모든 정보를 담을 때
             // 2. const config..는 차트의 설정을 미리 config(객체)로 정의한 후 이 객체를 사용하여 차트 생성
                lineChart = new Chart(ctx, {
                type: 'line',
                data: {
                   labels: date.slice(startIndex, startIndex + visibleCount),
                   datasets: [
                      {
                         label: 'Traffic',
                         data: tfData.slice(startIndex, startIndex + visibleCount),
                         tension: 0.5,
                         borderColor: 'rgb(68, 113, 218)',
                         borderWidth: 2,
                         pointRadius: 0,
          /*                fill: {\t* 임계값 설정 후 적용할 내용 * 
                      target: 1,
                      above: 'rgba(204, 61, 61, 0.4)',
                      below: 'rgba(255, 255, 255, 0)'
                   } */
                     }
                   ]
                },
                options: {
                   responsive: true,
                   scales: {
                      x: {
                         grid: {
                            display: false
                         }
                      },
                      y: {
                         beginAtZero: true,   // 축이 0부터 시작할지 여부
                         max: maxYValue
                      }
                   },
                   plugins: {
                      tooltip: {   // chart 위에 마우스를 올리면 데이터 포인트와 관련된 정보 표시
                         intersect: false,   // 마우스가 정확히 데이터 포인트 위에 있을 때만 표시될지 여부
                               // 기본값 : true, false면 포인트 가까이만 있어도 tooltip 표시
                         displayColors: false,   // label의 색상 상자 표시 여부
                         titleFont: {
                            size: 20,
                            family: 'Rethink Sans',
                            weight: 'bold'
                         },
                         bodyFont: {
                            size: 15,
                            family: 'Rethink Sans'
                         },
                         cornerRadius: 10,   // tooltip 둥근 모서리(기본값 : 6)
                         caretSize: 8,      // tooltip이 차트 요소를 가리키는 작은 삼각형
                         callbacks: {
                            title: function(tooltipItems){
                               return 'Details';
                            },
                            label: function(tooltipItems){
                               return '• Traffic  :  '+tooltipItems.raw;
                            },
                            afterLabel: function(tooltipItems){
                               const afterLabelInfo = [];
                               afterLabelInfo.push('• Date  :  '+tooltipItems.label);
                               
                               // memory, cpu 정보 넣기
                               const dataIndex = tooltipItems.dataIndex + startIndex;
                               
                               console.log("dataIndex: ", dataIndex)
                               
                               return afterLabelInfo;
                            }
                         }
                      }
                   },
                   hover : {
                      mode: 'index',      // 마우스를 올렸을 때 반응하는 차트 요소의 범위
                      intersect: false   // 마우스가 요소와 교차할 때만 호버 효과가 발생할지 여부 설정
                   },
                   animation: {
                      duration: 0
                   }
                }
             });
            
            function updateChart(){
               startIndex += 1;
               
               // 데이터의 끝에 도달하면 처음으로 돌아가도록 설정
                if (startIndex + visibleCount > date.length) {
                    startIndex = 0;
                }
               
               // 새로운 범위의 데이터로 차트 업데이트
               lineChart.data.labels = date.slice(startIndex, startIndex+visibleCount);
               lineChart.data.datasets[0].data = tfData.slice(startIndex, startIndex+visibleCount);
               
               // 새로운 범위로 차트 갱신
               lineChart.update();
            }
            
            // 0.8초마다 차트 자동으로 갱신하기
            // setInterval(updateChart, 800);
            
            // 업데이트 주기 설정
            updateInterval = setInterval(updateChart, 1000);
            
            // 일시정지 버튼 클릭 시 차트 업데이트
            document.getElementById('tempStop').addEventListener('click', function(){
               clearInterval(updateInterval);
               updateInterval = null;
            });
            
            // 재생 버튼 클릭 시 차트 업데이트
            document.getElementById('play').addEventListener('click', function() {
                // 기존 인터벌이 이미 멈춰있다면 재시작
                if (!updateInterval) {
                    updateInterval = setInterval(updateChart, 1000);
                }
            });
            
            },   
            error: function(){
               console.log("데이터 불러오기 실패")
            }
         });
      }
   });
   </script>

		<!-- ================================================================================ -->

		<script>
      const ctx = document.getElementById('barChart') ? document.getElementById('barChart').getContext('2d') : null;

      if (ctx) {
         // Data and threshold
         const dataBar = [5000, 4700, 3800, 4900, 4300, 7200, 3100];
         const thresholdBar = 5000;

         // Generate color array based on threshold
         const bgColorBar = dataBar.map(value => value > thresholdBar ? 'rgba(237, 169, 0, 0.7)' : 'rgba(18, 105, 120, 0.7)');

         // Create bar chart
         new Chart(ctx, {
            type: 'bar',
            data: {
               labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
               datasets: [{
                  label: 'Traffic',
                  data: dataBar,
                  backgroundColor: bgColorBar,
               }]
            },
            options: {
               scales: {
                  y: {
                     beginAtZero: false,
                     min: 1000,
                     max: 7000,
                     grid: {
                        display: true
                     }
                  },
                  x: {
                     grid: {
                        display: false
                     }
                  }
               },
               plugins: {
                  annotation: {
                     annotations: {
                        thresholdLine: {
                           type: 'line',
                           yMin: thresholdBar,
                           yMax: thresholdBar,
                           borderColor: 'rgba(237, 169, 0, 1)',
                           borderWidth: 2,
                           label: {
                              content: 'Threshold',
                              enabled: true,
                              position: 'right'
                           }
                        }
                     }
                  }
               },
               barPercentage: 0.6
            }
         });
      }

      function toggleNotification() {
         document.getElementById('notification').style.display = 'block';
      }

      function closeNotification() {
         document.getElementById('notification').style.display = 'none';
      }

      /* 드롭박스 */
      function toggleDropdown() {
         const dropdown = document.getElementById('dropdownMenu');
         dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
      }

      function selectLanguage(language) {
         const flag = document.getElementById('languageFlag');
         const languageText = document.querySelector('.english .language');
         const dropdown = document.getElementById('dropdownMenu');
         const koreaMenuItem = document.getElementById('koreaMenuItem');
         const englishMenuItem = document.getElementById('englishMenuItem');

         if (language === 'Korea') {
            flag.src = 'img/korea.png'; // 플래그 이미지 변경
            languageText.textContent = 'Korea'; // 상단의 언어 이름 변경
            koreaMenuItem.style.display = 'none'; // 한국어 항목 숨김
            englishMenuItem.style.display = 'block'; // 영어 항목 보임
         } else {
            flag.src = 'img/English.png'; // English 이미지로 변경
            languageText.textContent = 'English'; // 상단의 언어 이름 변경
            koreaMenuItem.style.display = 'block'; // 한국어 항목 보임
            englishMenuItem.style.display = 'none'; // 영어 항목 숨김
         }

         dropdown.style.display = 'none'; // 드롭다운 닫기
      }
   </script>

		<script>
    // 주기적으로 API를 호출하여 txRate와 traffic 비교
    setInterval(async function() {
        try {
            const response = await fetch('/api/alerts/check-traffic');
            const isAlert = await response.json();

            // 조건에 맞는 경우 알림 표시
            if (isAlert) {
                document.getElementById('notification').style.display = 'block';
            }
        } catch (error) {
            console.error('Error checking traffic alert:', error);
        }
    }, 5000); // 5초마다 확인 (필요에 따라 조정 가능)

    function closeNotification() {
        document.getElementById('notification').style.display = 'none';
    }
</script>


		
</body>
</html>
